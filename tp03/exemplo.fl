/*
 * nao sei o que e pra fazer aqui... o que faco e comparar
 * os elems do arr. se forem todos iguais da true
 */
is_square :: s: int[4] -> bool
{
    i: int = 1;

    while (&& (< i 4) (== s[i] s[(pred i)])) {
        i = (succ i);
    }

    return (== i 4);
}

/* max entre 2 numeros inteiros */
max :: a: int -> b: int -> int
{
    return (cond (< a b) b a);
}

/* min entre 2 numeros inteiros */
min :: a: int -> b: int -> int
{
    return (cond (< a b) a b);
}

/* produtorio de um array */
prod :: N: int -> arr: int[N] -> int
{
    ret: int = arr[0];
    i: int = 1;

    while (< i N) {
        ret = (* ret arr[i]);
        i = (succ i);
    }

    return ret;
}

/* sumatorio de um array */
sum :: N: int -> arr: int[N] -> int
{
    ret: int = arr[0];
    i: int = 1;

    while (< i N) {
        ret = (+ ret arr[i]);
        i = (succ i);
    }

    return ret;
}

/* toda gente sabe esta */
reverse :: N: int -> arr: int[N] -> int[N]
{
    l: int = 0;
    r: int = 0;
    tmp: int = 0;

    while (< l r) {
        tmp = arr[l];
        arr[l] = arr[r];
        arr[r] = tmp;
        l = (succ l);
        r = (pred r);
    }

    return arr;
}

/* max de um array de inteiros */
arrmax :: N: int -> arr: int[N] -> int
{
    ret: int = arr[0];
    i: int = 1;

    while (< i N) {
        ret = (max ret arr[i]);
        i = (succ i)
    }

    return ret;
}

/* min de um array de inteiros */
arrmin :: N: int -> arr: int[N] -> int
{
    ret: int = arr[0];
    i: int = 1;

    while (< i N) {
        ret = (min ret arr[i]);
        i = (succ i)
    }

    return ret;
}

/* insert ordenado */
insert :: N: int -> arr: int[N] -> elem: int -> int[N]
{
    i: int = N;

    while (&& (> i 0) (> elem arr[i])) {
        arr[i] = arr[(pred i)];
        i = (pred i);
    }

    arr[i] = elem;

    return arr;
}

/* sort de um array */
insertion_sort :: N: int -> arr: int[N] -> int[N] {
    w: int = 0;

    while (< w N) {
        arr = (insert w arr arr[w]);
        w = (succ w);
    }

    return arr;
}

abs :: x: int -> int
{
    return (cond (< x 0) (* -1 x) x);
}

is_even :: N: int -> bool
{
    N = (abs N);

    while (> N 1) {
        N = (- N 2);
    }

    return (== N 0);
}

/* filtra numeros pares */
impares :: N: int -> arr: int[N] -> int
{
    i: int = 0;
    w: int = 0;

    while (i < N) {
       e: bool = (is_even arr[i]);

       arr[w] = (cond e arr[w] arr[i]);
       w = (cond e w (succ w));

       /* alternativa a `cond` para blocos em vez de valores
        case e {
            false {
                arr[w] = arr[i];
                w = (succ w);
            }
        }
        */

       i = (succ i);
    }

    return w;
}

/* le `N` elementos para `arr` do `stdin` */
arrread :: N: int -> arr: int[N] -> N
{
    i: int = 0;

    while (< i N) {
        arr[i] = (read);
        i = (succ i);
    }

    return i;
}

/* imprime `N` elementos de `arr` pra `stdout` */
arrprint :: N: int -> arr: int[N] -> bool
{
    i: int = 0;

    while (< i N) {
        (print arr[i]);
        i = (succ i);
    }

    return true;
}

/* Ler 4 numeros e dizer se podem ser os lados de um quadrado (?) */
exe1 :: bool
{
    N: int = 4;
    arr: int[N];
    i: int = 0;

    N = (arrread N arr);

    sq: bool = (is_square arr);

    (print (cond sq "Sao quadrados\n" "Nao sao quadrados\n"));

    return sq;
}

/* Ler um inteiro N, depois ler N numeros e escrever o menor deles */
exe2 :: int
{
    N: int = (read);
    arr: int[N];
    i: int = 0;

    ret: int = (arrmin (arrread N arr) arr);

    (print ret);

    return ret;
}

/*
 * ler N (constante do programa) numeros e calcular e
 * imprimir o seu produtorio
 */
exe3 :: int
{
    N: int = 5;
    arr: int[N];

    ret: int = (prod (arrread N arr) arr);

    (print ret);

    return ret;
}

/*
 * contar e imprimir os numeros impares de uma sequencia
 * de numeros naturais
 */
exe4 :: int
{
    arr: int[11] = (-5 -4 -3 -2 -1 0 1 2 3 4 5);

    (arrprint (impares 11 arr) arr);

    return ret;
}

/*
 * ler e armazenar os elementos de um vector de comprimento N;
 * imprimir os valores por ordem decrescente apos fazer a
 * ordenacao do array por trocas directas
 */
exe5 :: int
{
    N: int = 10;
    arr: int[N];
    i: int = 0;

    N = (arrread N arr);

    (arrprint N (reverse N (insertion_sort N arr)));

    return N;
}

/*
 * ler e armazenar N numeros num array;
 * imprimir os valores por ordem inversa
 */
exe6 :: int
{
    N: int = 10;
    i: int = 0;
    arr: int[N];

    N = (arrread N arr);

    (arrprint N (reverse N arr));

    return N;
}
