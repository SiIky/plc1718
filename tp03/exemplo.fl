// nao sei o que e pra fazer aqui... o que faco e comparar
// os elems do arr. se forem todos iguais da true
is_square :: s: Int[] -> Int
{
    (= Int i 1)

    while (&& (< i 4) (== s[i] s[(-- i)])) {
        (= i (++ i))
    }

    (== i 4)
}

// max entre 2 numeros inteiros
max :: a: Int -> b: Int -> Int
{
    (? (> a b) a b)
}

// min entre 2 numeros inteiros
min :: a: Int -> b: Int -> Int
{
    (? (< a b) a b)
}

// produtorio de um array
prod :: N: Int -> arr: Int[] -> Int
{
    (= Int r arr[0])
    (= Int i 1)

    while (< i N) {
        (= r (* r arr[i]))
        (= i (++ i))
    }

    r
}

// sumatorio de um array
sum :: N: Int -> arr: Int[] -> Int
{
    (= Int r arr[0])
    (= Int i 1)

    while (< i N) {
        (= r (+ r arr[i]))
        (= i (++ i))
    }

    r
}

// toda gente sabe esta
reverse :: N: Int -> arr: Int[] -> Int[]
{
    (= Int l 0)
    (= Int r 0)
    (= Int tmp 0)

    while (< l r) {
        (= tmp    arr[l])
        (= arr[l] arr[r])
        (= arr[r] tmp)
        (= l      (++ l))
        (= r      (-- r))
    }

    arr
}

// max de um array de inteiros
arrmax :: N: Int -> arr: Int[] -> Int
{
    (= Int r arr[0])
    (= Int i 1)

    while (< i N) {
        (= r (max r arr[i]))
        (= i (++ i))
    }

    r
}

// min de um array de inteiros
arrmin :: N: Int -> arr: Int[] -> Int
{
    (= Int r arr[0])
    (= Int i 1)

    while (< i N) {
        (= r (min r arr[i]))
        (= i (++ i))
    }

    r
}

// insert ordenado
insert :: N: Int -> arr: Int[] -> elem: Int -> Int[]
{
    (= Int i N)

    while (&& (> i 0) (> elem arr[i])) {
        (= arr[i] arr[(-- i)])
        (= i (-- i))
    }

    (= arr[i] elem)
    arr
}

// sort de um array
insertion_sort :: N: Int -> arr: Int[] -> Int[] {
    (= Int w 0)

    while (< w N) {
        (= arr (insert w arr arr[w]))
        (= w (++ w))
    }

    arr
}

abs :: x: Int -> Int
{
    (? (< x 0) (* -1 x) x)
}

is_even_iter :: N: Int -> Int
{
    (= N (abs N))

    while (> N 1) {
        (= N (- N 2))
    }

    (== N 0)
}

// alternativa recursiva
is_even_rec :: N: Int -> Int
{
    (? (> N 1) (is_even_rec (- N 2))
    (? (< N 0) (is_even_rec (abs N))
                   N)) // 0 <= N <= 1
}

// filtra numeros pares
impares :: N: Int -> arr: Int[] -> Int
{
    (= Int i 0)
    (= Int w 0)
    (= Int e)

    while (i < N) {
       (= e (is_even_iter arr[i]))
       (= arr[w] (? e arr[w] arr[i]))
       (= w (? e w (++ w)))
       (= i (++ i))
    }

    w
}

// le `N` elementos para `arr` do `stdin`
arrread :: N: Int -> arr: Int[] -> Int
{
    (= Int i 0)

    while (< i N) {
        (= arr[i] (read))
        (= i (++ i))
    }

    i
}

// imprime `N` elementos de `arr` pra `stdout`
arrprint :: N: Int -> arr: Int[] -> Int
{
    (= Int i 0)

    while (< i N) {
        (print arr[i])
        (= i (++ i))
    }

    i
}

// Ler 4 numeros e dizer se podem ser os lados de um quadrado (?)
exe1 :: Int
{
    (= Int N 4)
    (= Int[] arr)
    (= N (arrread N arr))
    (= Int sq (is_square arr))
    (print (? sq "Sao quadrados\n" "Nao sao quadrados\n"))
    sq
}

// Ler um inteiro N, depois ler N numeros e escrever o menor deles
exe2 :: Int
{
    (= Int N (read))
    (= Int[] arr)
    (= Int r (arrmin (arrread N arr) arr))
    (print r)
    r
}

// ler N (constante do programa) numeros e calcular e
// imprimir o seu produtorio
exe3 :: Int
{
    (= Int N 5)
    (= Int[] arr)
    (= Int r (prod (arrread N arr) arr))
    (print r)
    ret
}

// contar e imprimir os numeros impares de uma sequencia
// de numeros naturais
exe4 :: Int
{
    (= Int arr[11] (-5 -4 -3 -2 -1 0 1 2 3 4 5))
    (arrprint (impares 11 arr) arr)
    ret
}

// ler e armazenar os elementos de um vector de comprimento N
// imprimir os valores por ordem decrescente apos fazer a
// ordenacao do array por trocas directas
exe5 :: Int
{
    (= Int N 10)
    (= Int[] arr)
    (= N (arrread N arr))
    (arrprint N (reverse N (insertion_sort N arr)))
    N
}

// ler e armazenar N numeros num array
// imprimir os valores por ordem inversa
exe6 :: Int
{
    (= Int N 10)
    (= Int[] arr)
    (= N (arrread N arr))
    (arrprint N (reverse N arr))
    N
}
